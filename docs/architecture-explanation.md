# DreamJournal アーキテクチャ説明メモ

## 📋 目的

このドキュメントは、DreamJournalアプリケーションのアーキテクチャについて、**面接で10分で説明できる**ようにまとめたものです。

技術選定の理由だけでなく、**本番運用で実際に起きた問題と解決策**も含めています。

---

## 🎯 システム全体のアーキテクチャ

### **概要**

DreamJournalは、**Next.js 15（フロントエンド）** + **Rails 8 API（バックエンド）** + **Supabase（データベース・認証）** で構成されたフルスタックアプリケーションです。

```
┌─────────────────────────────────────────────────────────────┐
│                        ユーザー                              │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                   フロントエンド                             │
│                   Next.js 15 (App Router)                   │
│                   Vercel でデプロイ                          │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                   バックエンド                               │
│                   Rails 8 API mode                          │
│                   Render でデプロイ                          │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                   データベース・認証                         │
│                   Supabase (PostgreSQL + Auth)              │
└─────────────────────────────────────────────────────────────┘
```

---

## 🔧 技術選定の理由

### **1. なぜNext.js 15を選んだか？**

#### **選定理由**

1. **App Routerによるモダンな開発体験**
   - Server ComponentsとClient Componentsの使い分けにより、パフォーマンスとUXを両立
   - ファイルベースルーティングにより、直感的なページ構成

2. **SEO対策**
   - Server-Side Rendering（SSR）により、検索エンジンに優しい
   - メタタグの動的生成により、SNSシェア時のプレビューも最適化

3. **開発効率**
   - TypeScriptによる型安全性
   - Hot Reloadによる高速な開発サイクル

4. **デプロイの簡単さ**
   - Vercelとの親和性が高く、デプロイが簡単
   - 自動的にプレビュー環境が作成される

#### **実際の使用例**

- **Server Components**: 夢の一覧表示（`app/dreams/page.tsx`）
- **Client Components**: 夢の作成フォーム（`app/dreams/new/page.tsx`）
- **動的ルーティング**: 夢の詳細表示（`app/dreams/[id]/page.tsx`）

---

### **2. なぜAPI分離（Rails 8）を選んだか？**

#### **選定理由**

1. **フロントエンドとバックエンドの分離**
   - フロントエンドとバックエンドを独立して開発・デプロイできる
   - 技術スタックの変更が容易（例：Next.jsをReactに変更しても、バックエンドは変更不要）

2. **スケーラビリティ**
   - フロントエンドとバックエンドを別々にスケールできる
   - 負荷分散が容易

3. **RESTful APIの設計**
   - リソースベースのルーティングにより、APIの設計が直感的
   - HTTPメソッド（GET、POST、PUT、DELETE）により、操作が明確

4. **Rails 8の新機能**
   - Kamalによる簡単なデプロイ
   - Solid Cacheによる高速なキャッシュ

#### **実際の使用例**

- **夢の一覧取得**: `GET /dreams`
- **夢の作成**: `POST /dreams`
- **夢の分析**: `POST /dreams/:id/analyze`

---

### **3. なぜSupabaseを選んだか？**

#### **選定理由**

1. **PostgreSQLベースのデータベース**
   - リレーショナルデータベースとして、データの整合性を保証
   - SQLによる柔軟なクエリ

2. **Supabase Authによる認証**
   - JWTトークンによる認証
   - メールアドレス・パスワードによるログイン
   - セッション管理

3. **コスト効率**
   - 無料プランで500MB、50,000リクエスト/月
   - 有料プランでも$25/月から

4. **Row Level Security（RLS）**
   - データベースレベルでのセキュリティ
   - ユーザーごとにデータを分離

#### **実際の使用例**

- **ユーザー認証**: Supabase Authによるログイン・ログアウト
- **夢データの保存**: PostgreSQLによるデータ保存
- **RLSポリシー**: ユーザーごとに夢データを分離（将来的に実装予定）

---

### **4. なぜSentryを選んだか？**

#### **選定理由**

1. **エラー監視**
   - 本番環境でのエラーをリアルタイムで検知
   - エラーの詳細情報（スタックトレース、ユーザー情報）を取得

2. **パフォーマンス監視**
   - ページの読み込み時間を監視
   - APIのレスポンス時間を監視

3. **本番運用の安定性**
   - エラーが発生した際に、すぐに対応できる
   - ユーザーに影響が出る前に問題を検知

4. **無料プランの充実**
   - 5,000イベント/月まで無料

#### **実際の使用例**

- **フロントエンドのエラー監視**: Next.jsでのエラーを検知
- **バックエンドのエラー監視**: Railsでのエラーを検知
- **パフォーマンス監視**: ページの読み込み時間を監視

### **5. なぜVercel Rewrite（クロスドメイン認証）？**

#### **問題**

- フロントエンド（`dreamjournal-app.vercel.app`）とバックエンド（`dreamjournal-app.onrender.com`）が**異なるドメイン**
- ブラウザのセキュリティ制限により、**サードパーティCookie**が送信されない
- → ログイン後もCookieが送信されず、認証が切れてしまう

#### **解決策: Vercel Rewrite**

```
ユーザー → dreamjournal-app.vercel.app/api/*
           ↓ （Vercel Rewriteで透過的にプロキシ）
         dreamjournal-app.onrender.com/*
```

- Vercelの`rewrites`機能で、`/api/*`へのリクエストをバックエンドに転送
- ブラウザから見ると**同一ドメイン**なので、Cookieが正常に送信される
- **ファーストパーティCookie**として扱われるため、セキュリティ制限を回避

#### **設定（`next.config.ts`）**

```javascript
async rewrites() {
  return [
    {
      source: '/api/:path*',
      destination: 'https://dreamjournal-app.onrender.com/:path*',
    },
  ];
}
```

#### **面接での説明ポイント**

> 「フロントとバックが異なるドメインで動いているため、Chrome等のサードパーティCookie制限に引っかかりました。Vercel Rewriteで同一ドメインからのリクエストに見せることで解決しました。本番環境特有の問題で、開発環境では気づけなかった点です。」

---

### **6. なぜ環境変数で設定管理？**

#### **選定理由**

1. **セキュリティ**
   - APIキー等の秘密情報をコードに含めない
   - `.env`ファイルは`.gitignore`で管理対象外

2. **環境の分離**
   - 開発環境: ローカルの`.env`ファイル
   - 本番環境: Renderの環境変数設定
   - テスト環境: CI/CDの環境変数

3. **柔軟な運用**
   - `RUN_SEED=true`のような一時的なフラグで動作制御
   - コードを変更せずに設定を変更可能

#### **実際に起きた問題**

| 環境変数 | 問題 | 影響 |
|---|---|---|
| `OPENAI_API_KEY=dummy` | 本番環境にダミー値が設定されていた | 夢分析機能が動作しない |
| `RUN_SEED` 未設定 | 本番DBに初期データがない | 感情タグが表示されない |

→ **環境変数の管理は「設定したつもり」が一番危険**だと学んだ

---

## 🔐 認証フロー

```
┌─────────────────────────────────────────────────────────────┐
│  1. ユーザーがログインフォームにメールアドレス・パスワードを入力  │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│  2. フロントエンド（Next.js）がバックエンド（Rails）に           │
│     POST /auth/login リクエストを送信                        │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│  3. バックエンド（Rails）がSupabase Authに認証リクエストを送信   │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│  4. Supabase AuthがJWTトークンを返す                          │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│  5. バックエンド（Rails）がJWTトークンをフロントエンドに返す      │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│  6. フロントエンド（Next.js）がJWTトークンをCookieに保存         │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│  7. 以降のリクエストでJWTトークンをAuthorizationヘッダーに含める  │
└─────────────────────────────────────────────────────────────┘
```

---

## 🚀 デプロイフロー

```
┌─────────────────────────────────────────────────────────────┐
│  1. GitHubにコードをプッシュ                                  │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│  2. GitHub Actionsが自動的にテストを実行                      │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│  3. テストが成功したら、Vercel（フロントエンド）と              │
│     Render（バックエンド）に自動デプロイ                      │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│  4. デプロイが完了したら、本番環境で動作確認                   │
└─────────────────────────────────────────────────────────────┘
```

---

## 📊 運用実績

- **本番運用期間**: 40日間以上（2026年1月1日〜）
- **重大障害**: 0件
- **エラー監視**: Sentryによるリアルタイム監視
- **パフォーマンス**: ページ読み込み時間 < 2秒

---

## 🔥 本番運用で実際に起きた問題と解決策

### **問題1: サードパーティCookieによる認証断絶（2026年2月）**

| 項目 | 内容 |
|---|---|
| **症状** | 本番環境でログインしても、ページ遷移後に認証が切れる |
| **原因** | フロントとバックが異なるドメインで、サードパーティCookieがブロックされていた |
| **調査方法** | ブラウザのDevTools → Networkタブ → Cookieが送信されていないことを確認 |
| **解決策** | Vercel Rewriteでバックエンドを同一ドメイン経由に変更 |
| **学び** | 開発環境（localhost）では発生しない、本番環境特有の問題がある |

### **問題2: 本番DBに初期データがない（2026年2月）**

| 項目 | 内容 |
|---|---|
| **症状** | `/dream/new`で「感情タグがありません」と表示される |
| **原因** | 本番環境で`rails db:seed`が実行されておらず、emotionsテーブルが空 |
| **調査方法** | Renderのログで感情データの読み込み状況を確認 |
| **解決策** | `RUN_SEED=true`環境変数による本番シード実行の仕組みを導入 |
| **学び** | 無料プラン（Shell非対応）でもエントリーポイントスクリプトで対応可能 |

### **問題3: OpenAI APIキーがダミー値（2026年2月）**

| 項目 | 内容 |
|---|---|
| **症状** | 「モルペウスと おはなし できなかった」と表示される |
| **原因** | Renderの`OPENAI_API_KEY`が`dummy`に設定されていた |
| **調査方法** | ① Renderログでエラーを確認 → ② OpenAIダッシュボードでリクエスト0件を確認 → ③ Renderの環境変数を確認 |
| **解決策** | ① 正しいAPIキーを設定 ② nilチェックのコードを追加 |
| **学び** | 外部APIの応答は必ず`nil`チェックしてから使う（防御的プログラミング） |

### **面接での説明ポイント**

> 「本番運用では開発環境では起きない問題に3つ直面しました。」
>
> 「1つ目はクロスドメインのCookie問題。VercelとRenderが異なるドメインのため、サードパーティCookieがブラウザにブロックされました。Vercel Rewriteで同一ドメインに見せることで解決しました。」
>
> 「2つ目はシードデータの問題。Renderの無料プランではShellアクセスができないので、環境変数フラグで制御する仕組みを作りました。」
>
> 「3つ目はAPIキーの設定ミス。ログ分析とOpenAIダッシュボードの両面から原因を切り分け、さらに同じ問題が起きないようnilチェックのコードを追加しました。」
>
> 「いずれも、ログを読んで仮説を立て、一つずつ検証して解決するプロセスを実践しました。」

---

## 🎯 今後の改善点

1. **RLSポリシーの実装**
   - ユーザーごとに夢データを分離
   - データベースレベルでのセキュリティ強化

2. **パフォーマンス最適化**
   - 画像の最適化（Next.js Image）
   - キャッシュ戦略の改善

3. **テストカバレッジの向上**
   - フロントエンドのテストカバレッジ: 80%以上
   - バックエンドのテストカバレッジ: 90%以上

---

## 💡 面接での説明例

### 3分バージョン（技術選定）

> 「DreamJournalは、Next.js 15とRails 8 APIで構成されたフルスタックアプリケーションです。」
> 
> 「フロントエンドにNext.js 15を選んだ理由は、App Routerによるモダンな開発体験と、SEO対策です。Server ComponentsとClient Componentsを使い分けることで、パフォーマンスとUXを両立しています。」
> 
> 「バックエンドにRails 8 APIを選んだ理由は、フロントエンドとバックエンドを分離することで、スケーラビリティと技術スタックの柔軟性を確保するためです。」
> 
> 「データベースにSupabaseを選んだ理由は、PostgreSQLベースでコスト効率が良いためです。エラー監視にはSentryを導入し、40日以上の本番運用で重大障害0件を達成しています。」

### 5分バージョン（トラブルシューティング力）

> 上記に加えて：
> 
> 「特に学びが深かったのは、本番環境特有の問題への対応です。開発環境のlocalhostでは起きない、クロスドメインのCookie問題にぶつかりました。Vercel Rewriteで同一ドメインに見せる方法で解決しましたが、開発と本番の環境差異を意識する重要性を学びました。」
> 
> 「また、OpenAI APIキーの設定ミスでは、Renderのログ分析 → OpenAIダッシュボードの確認 → 環境変数の照合という順で原因を切り分けました。さらに、同じ問題が起きても分かりやすいエラーメッセージが出るよう、nilチェックのコードも追加しました。」

### 10分バージョン（運用者としての判断力）

> 上記に加えて：
>
> 「コスト管理も意識しています。現在は完全無料で運用していますが、もし1万人ユーザーが来た場合の試算も行っています。最初にボトルネックになるのはSupabaseのAPIリクエスト数で、月額約$80で対応可能です。」
>
> 「Renderの無料プランではShellアクセスができないため、本番のシードデータ投入には`RUN_SEED`環境変数による制御の仕組みを作りました。シード自体は冪等（`find_or_create_by`を使用）なので、複数回実行しても安全です。ただし毎回実行する必要はないため、初回投入後は環境変数を削除する運用にしています。」
>
> 「このように、機能開発だけでなく、コスト管理、エラーハンドリング、運用の自動化まで含めて、プロダクトを『運用できる状態』にすることを意識しています。」

---

## 📚 参考資料

- [Next.js 15 Documentation](https://nextjs.org/docs)
- [Rails 8 API Documentation](https://guides.rubyonrails.org/api_app.html)
- [Supabase Documentation](https://supabase.com/docs)
- [Sentry Documentation](https://docs.sentry.io/)

---

**作成日**: 2026年1月27日
**更新日**: 2026年2月11日（本番運用実績・トラブルシューティング事例を追加）
**作成者**: isekaisaru
**目的**: 面接でアーキテクチャを10分で説明できるようにする
